<?php
/**
 * MultiStepAuthenticationChallenge
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * finAPI RESTful Services
 *
 * finAPI RESTful Services
 *
 * OpenAPI spec version: v1.81.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.8
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * MultiStepAuthenticationChallenge Class Doc Comment
 *
 * @category Class
 * @description Container for multi-step authentication data, as returned by finAPI to the client
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class MultiStepAuthenticationChallenge implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'MultiStepAuthenticationChallenge';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'hash' => 'string',
        'status' => 'string',
        'challenge_message' => 'string',
        'answer_field_label' => 'string',
        'redirect_url' => 'string',
        'redirect_context' => 'string',
        'redirect_context_field' => 'string',
        'two_step_procedures' => '\Swagger\Client\Model\TwoStepProcedure[]',
        'optical_data' => 'string',
        'photo_tan_mime_type' => 'string',
        'photo_tan_data' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'hash' => null,
        'status' => null,
        'challenge_message' => null,
        'answer_field_label' => null,
        'redirect_url' => null,
        'redirect_context' => null,
        'redirect_context_field' => null,
        'two_step_procedures' => null,
        'optical_data' => null,
        'photo_tan_mime_type' => null,
        'photo_tan_data' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'hash' => 'hash',
        'status' => 'status',
        'challenge_message' => 'challengeMessage',
        'answer_field_label' => 'answerFieldLabel',
        'redirect_url' => 'redirectUrl',
        'redirect_context' => 'redirectContext',
        'redirect_context_field' => 'redirectContextField',
        'two_step_procedures' => 'twoStepProcedures',
        'optical_data' => 'opticalData',
        'photo_tan_mime_type' => 'photoTanMimeType',
        'photo_tan_data' => 'photoTanData'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'hash' => 'setHash',
        'status' => 'setStatus',
        'challenge_message' => 'setChallengeMessage',
        'answer_field_label' => 'setAnswerFieldLabel',
        'redirect_url' => 'setRedirectUrl',
        'redirect_context' => 'setRedirectContext',
        'redirect_context_field' => 'setRedirectContextField',
        'two_step_procedures' => 'setTwoStepProcedures',
        'optical_data' => 'setOpticalData',
        'photo_tan_mime_type' => 'setPhotoTanMimeType',
        'photo_tan_data' => 'setPhotoTanData'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'hash' => 'getHash',
        'status' => 'getStatus',
        'challenge_message' => 'getChallengeMessage',
        'answer_field_label' => 'getAnswerFieldLabel',
        'redirect_url' => 'getRedirectUrl',
        'redirect_context' => 'getRedirectContext',
        'redirect_context_field' => 'getRedirectContextField',
        'two_step_procedures' => 'getTwoStepProcedures',
        'optical_data' => 'getOpticalData',
        'photo_tan_mime_type' => 'getPhotoTanMimeType',
        'photo_tan_data' => 'getPhotoTanData'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const STATUS_CHALLENGE_RESPONSE_REQUIRED = 'CHALLENGE_RESPONSE_REQUIRED';
    const STATUS_TWO_STEP_PROCEDURE_REQUIRED = 'TWO_STEP_PROCEDURE_REQUIRED';
    const STATUS_REDIRECT_REQUIRED = 'REDIRECT_REQUIRED';
    const STATUS_DECOUPLED_AUTH_REQUIRED = 'DECOUPLED_AUTH_REQUIRED';
    const STATUS_DECOUPLED_AUTH_IN_PROGRESS = 'DECOUPLED_AUTH_IN_PROGRESS';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_CHALLENGE_RESPONSE_REQUIRED,
            self::STATUS_TWO_STEP_PROCEDURE_REQUIRED,
            self::STATUS_REDIRECT_REQUIRED,
            self::STATUS_DECOUPLED_AUTH_REQUIRED,
            self::STATUS_DECOUPLED_AUTH_IN_PROGRESS,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['hash'] = isset($data['hash']) ? $data['hash'] : null;
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
        $this->container['challenge_message'] = isset($data['challenge_message']) ? $data['challenge_message'] : null;
        $this->container['answer_field_label'] = isset($data['answer_field_label']) ? $data['answer_field_label'] : null;
        $this->container['redirect_url'] = isset($data['redirect_url']) ? $data['redirect_url'] : null;
        $this->container['redirect_context'] = isset($data['redirect_context']) ? $data['redirect_context'] : null;
        $this->container['redirect_context_field'] = isset($data['redirect_context_field']) ? $data['redirect_context_field'] : null;
        $this->container['two_step_procedures'] = isset($data['two_step_procedures']) ? $data['two_step_procedures'] : null;
        $this->container['optical_data'] = isset($data['optical_data']) ? $data['optical_data'] : null;
        $this->container['photo_tan_mime_type'] = isset($data['photo_tan_mime_type']) ? $data['photo_tan_mime_type'] : null;
        $this->container['photo_tan_data'] = isset($data['photo_tan_data']) ? $data['photo_tan_data'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['hash'] === null) {
            $invalidProperties[] = "'hash' can't be null";
        }
        if ($this->container['status'] === null) {
            $invalidProperties[] = "'status' can't be null";
        }
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'status', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets hash
     *
     * @return string
     */
    public function getHash()
    {
        return $this->container['hash'];
    }

    /**
     * Sets hash
     *
     * @param string $hash Hash for this multi-step authentication flow. Must be passed back to finAPI when continuing the flow.
     *
     * @return $this
     */
    public function setHash($hash)
    {
        $this->container['hash'] = $hash;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string $status Indicates the current status of the multi-step authentication flow:<br/><br/>TWO_STEP_PROCEDURE_REQUIRED means that the bank has requested an SCA method selection for the user. In this case, the service should be recalled with a chosen TSP-ID set to the 'twoStepProcedureId' field.<br/>When the web form flow is used, the user is forwarded to finAPI's web form to prompt for his credentials (if they are not stored in finAPI) and to select the preferred SCA method.<br/><br/>CHALLENGE_RESPONSE_REQUIRED means that the bank has requested a challenge code for the previously given TSP (SCA). This status can be completed by setting the 'challengeResponse' field.<br/>When the web form flow is used, the user should submit the challenge response for the challenge message shown by the web form.<br/><br/>REDIRECT_REQUIRED means that the user must be redirected to the bank's website, where the authentication can be finished.<br/>When the web form flow is used, the user should visit the web form, get a redirect to the bank's website, complete the authentication and will then be redirected back to the web form.<br/><br/>DECOUPLED_AUTH_REQUIRED means that the bank has asked for the decoupled authentication. In this case, the 'decoupledCallback' field must be set to true to complete the authentication.<br/><br/>DECOUPLED_AUTH_IN_PROGRESS means that the bank is waiting for the completion of the decoupled authentication by the user. Until this is done, the service should be recalled with the 'decoupledCallback' field set to ‘true’. Once the decoupled authentication is completed by the user, the service returns a successful response.
     *
     * @return $this
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'status', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets challenge_message
     *
     * @return string
     */
    public function getChallengeMessage()
    {
        return $this->container['challenge_message'];
    }

    /**
     * Sets challenge_message
     *
     * @param string $challenge_message In case of status = CHALLENGE_RESPONSE_REQUIRED, this field contains a message from the bank containing instructions for the user on how to proceed with the authorization.
     *
     * @return $this
     */
    public function setChallengeMessage($challenge_message)
    {
        $this->container['challenge_message'] = $challenge_message;

        return $this;
    }

    /**
     * Gets answer_field_label
     *
     * @return string
     */
    public function getAnswerFieldLabel()
    {
        return $this->container['answer_field_label'];
    }

    /**
     * Sets answer_field_label
     *
     * @param string $answer_field_label Suggestion from the bank on how you can label your input field where the user should enter his challenge response.
     *
     * @return $this
     */
    public function setAnswerFieldLabel($answer_field_label)
    {
        $this->container['answer_field_label'] = $answer_field_label;

        return $this;
    }

    /**
     * Gets redirect_url
     *
     * @return string
     */
    public function getRedirectUrl()
    {
        return $this->container['redirect_url'];
    }

    /**
     * Sets redirect_url
     *
     * @param string $redirect_url In case of status = REDIRECT_REQUIRED, this field contains the URL to which you must direct the user. It already includes the redirect URL back to your client that you have passed when initiating the service call.
     *
     * @return $this
     */
    public function setRedirectUrl($redirect_url)
    {
        $this->container['redirect_url'] = $redirect_url;

        return $this;
    }

    /**
     * Gets redirect_context
     *
     * @return string
     */
    public function getRedirectContext()
    {
        return $this->container['redirect_context'];
    }

    /**
     * Sets redirect_context
     *
     * @param string $redirect_context Set in case of status = REDIRECT_REQUIRED. When the bank redirects the user back to your client, the redirect URL will contain this string, which you must process to identify the user context for the callback on your side.
     *
     * @return $this
     */
    public function setRedirectContext($redirect_context)
    {
        $this->container['redirect_context'] = $redirect_context;

        return $this;
    }

    /**
     * Gets redirect_context_field
     *
     * @return string
     */
    public function getRedirectContextField()
    {
        return $this->container['redirect_context_field'];
    }

    /**
     * Sets redirect_context_field
     *
     * @param string $redirect_context_field Set in case of status = REDIRECT_REQUIRED. This field is set to the name of the query parameter that contains the 'redirectContext' in the redirect URL from the bank back to your client.
     *
     * @return $this
     */
    public function setRedirectContextField($redirect_context_field)
    {
        $this->container['redirect_context_field'] = $redirect_context_field;

        return $this;
    }

    /**
     * Gets two_step_procedures
     *
     * @return \Swagger\Client\Model\TwoStepProcedure[]
     */
    public function getTwoStepProcedures()
    {
        return $this->container['two_step_procedures'];
    }

    /**
     * Sets two_step_procedures
     *
     * @param \Swagger\Client\Model\TwoStepProcedure[] $two_step_procedures In case of status = TWO_STEP_PROCEDURE_REQUIRED, this field contains the available two-step procedures. Note that this set does not necessarily match the set that is stored in the respective bank connection interface. You should always use the set from this field for the multi-step authentication flow.
     *
     * @return $this
     */
    public function setTwoStepProcedures($two_step_procedures)
    {
        $this->container['two_step_procedures'] = $two_step_procedures;

        return $this;
    }

    /**
     * Gets optical_data
     *
     * @return string
     */
    public function getOpticalData()
    {
        return $this->container['optical_data'];
    }

    /**
     * Sets optical_data
     *
     * @param string $optical_data In case that the bank server has instructed the user to scan a flicker code, then this field will contain the raw data for the flicker animation as a BASE-64 string.
     *
     * @return $this
     */
    public function setOpticalData($optical_data)
    {
        $this->container['optical_data'] = $optical_data;

        return $this;
    }

    /**
     * Gets photo_tan_mime_type
     *
     * @return string
     */
    public function getPhotoTanMimeType()
    {
        return $this->container['photo_tan_mime_type'];
    }

    /**
     * Sets photo_tan_mime_type
     *
     * @param string $photo_tan_mime_type In case that the 'photoTanData' field is set (i.e. not null), this field contains the MIME type to use for interpreting the photo data (e.g.: 'image/png')
     *
     * @return $this
     */
    public function setPhotoTanMimeType($photo_tan_mime_type)
    {
        $this->container['photo_tan_mime_type'] = $photo_tan_mime_type;

        return $this;
    }

    /**
     * Gets photo_tan_data
     *
     * @return string
     */
    public function getPhotoTanData()
    {
        return $this->container['photo_tan_data'];
    }

    /**
     * Sets photo_tan_data
     *
     * @param string $photo_tan_data In case that the bank server has instructed the user to scan a photo (or more generally speaking, any kind of QR-code-like data), then this field will contain the raw data of the photo as a BASE-64 string.
     *
     * @return $this
     */
    public function setPhotoTanData($photo_tan_data)
    {
        $this->container['photo_tan_data'] = $photo_tan_data;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


