<?php
/**
 * Account
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * finAPI RESTful Services
 *
 * finAPI RESTful Services
 *
 * OpenAPI spec version: v1.81.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.8
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * Account Class Doc Comment
 *
 * @category Class
 * @description Container for a bank account&#39;s data
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Account implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'Account';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'id' => 'int',
        'bank_connection_id' => 'int',
        'account_name' => 'string',
        'iban' => 'string',
        'account_number' => 'string',
        'sub_account_number' => 'string',
        'account_holder_name' => 'string',
        'account_holder_id' => 'string',
        'account_currency' => 'string',
        'account_type_id' => 'int',
        'account_type_name' => 'string',
        'account_type' => 'string',
        'balance' => 'float',
        'overdraft' => 'float',
        'overdraft_limit' => 'float',
        'available_funds' => 'float',
        'last_successful_update' => 'string',
        'last_update_attempt' => 'string',
        'is_new' => 'bool',
        'status' => 'string',
        'supported_orders' => 'string[]',
        'interfaces' => '\Swagger\Client\Model\AccountInterface[]',
        'clearing_accounts' => '\Swagger\Client\Model\ClearingAccountData[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'id' => 'int64',
        'bank_connection_id' => 'int64',
        'account_name' => null,
        'iban' => null,
        'account_number' => null,
        'sub_account_number' => null,
        'account_holder_name' => null,
        'account_holder_id' => null,
        'account_currency' => null,
        'account_type_id' => 'int64',
        'account_type_name' => null,
        'account_type' => null,
        'balance' => null,
        'overdraft' => null,
        'overdraft_limit' => null,
        'available_funds' => null,
        'last_successful_update' => null,
        'last_update_attempt' => null,
        'is_new' => null,
        'status' => null,
        'supported_orders' => null,
        'interfaces' => null,
        'clearing_accounts' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'bank_connection_id' => 'bankConnectionId',
        'account_name' => 'accountName',
        'iban' => 'iban',
        'account_number' => 'accountNumber',
        'sub_account_number' => 'subAccountNumber',
        'account_holder_name' => 'accountHolderName',
        'account_holder_id' => 'accountHolderId',
        'account_currency' => 'accountCurrency',
        'account_type_id' => 'accountTypeId',
        'account_type_name' => 'accountTypeName',
        'account_type' => 'accountType',
        'balance' => 'balance',
        'overdraft' => 'overdraft',
        'overdraft_limit' => 'overdraftLimit',
        'available_funds' => 'availableFunds',
        'last_successful_update' => 'lastSuccessfulUpdate',
        'last_update_attempt' => 'lastUpdateAttempt',
        'is_new' => 'isNew',
        'status' => 'status',
        'supported_orders' => 'supportedOrders',
        'interfaces' => 'interfaces',
        'clearing_accounts' => 'clearingAccounts'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'bank_connection_id' => 'setBankConnectionId',
        'account_name' => 'setAccountName',
        'iban' => 'setIban',
        'account_number' => 'setAccountNumber',
        'sub_account_number' => 'setSubAccountNumber',
        'account_holder_name' => 'setAccountHolderName',
        'account_holder_id' => 'setAccountHolderId',
        'account_currency' => 'setAccountCurrency',
        'account_type_id' => 'setAccountTypeId',
        'account_type_name' => 'setAccountTypeName',
        'account_type' => 'setAccountType',
        'balance' => 'setBalance',
        'overdraft' => 'setOverdraft',
        'overdraft_limit' => 'setOverdraftLimit',
        'available_funds' => 'setAvailableFunds',
        'last_successful_update' => 'setLastSuccessfulUpdate',
        'last_update_attempt' => 'setLastUpdateAttempt',
        'is_new' => 'setIsNew',
        'status' => 'setStatus',
        'supported_orders' => 'setSupportedOrders',
        'interfaces' => 'setInterfaces',
        'clearing_accounts' => 'setClearingAccounts'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'bank_connection_id' => 'getBankConnectionId',
        'account_name' => 'getAccountName',
        'iban' => 'getIban',
        'account_number' => 'getAccountNumber',
        'sub_account_number' => 'getSubAccountNumber',
        'account_holder_name' => 'getAccountHolderName',
        'account_holder_id' => 'getAccountHolderId',
        'account_currency' => 'getAccountCurrency',
        'account_type_id' => 'getAccountTypeId',
        'account_type_name' => 'getAccountTypeName',
        'account_type' => 'getAccountType',
        'balance' => 'getBalance',
        'overdraft' => 'getOverdraft',
        'overdraft_limit' => 'getOverdraftLimit',
        'available_funds' => 'getAvailableFunds',
        'last_successful_update' => 'getLastSuccessfulUpdate',
        'last_update_attempt' => 'getLastUpdateAttempt',
        'is_new' => 'getIsNew',
        'status' => 'getStatus',
        'supported_orders' => 'getSupportedOrders',
        'interfaces' => 'getInterfaces',
        'clearing_accounts' => 'getClearingAccounts'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const ACCOUNT_TYPE_CHECKING = 'Checking';
    const ACCOUNT_TYPE_SAVINGS = 'Savings';
    const ACCOUNT_TYPE_CREDIT_CARD = 'CreditCard';
    const ACCOUNT_TYPE_SECURITY = 'Security';
    const ACCOUNT_TYPE_LOAN = 'Loan';
    const ACCOUNT_TYPE_POCKET = 'Pocket';
    const ACCOUNT_TYPE_MEMBERSHIP = 'Membership';
    const ACCOUNT_TYPE_BAUSPAREN = 'Bausparen';
    const STATUS_UPDATED = 'UPDATED';
    const STATUS_UPDATED_FIXED = 'UPDATED_FIXED';
    const STATUS_DOWNLOAD_IN_PROGRESS = 'DOWNLOAD_IN_PROGRESS';
    const STATUS_DOWNLOAD_FAILED = 'DOWNLOAD_FAILED';
    const STATUS_DEPRECATED = 'DEPRECATED';
    const SUPPORTED_ORDERS_MONEY_TRANSFER = 'SEPA_MONEY_TRANSFER';
    const SUPPORTED_ORDERS_COLLECTIVE_MONEY_TRANSFER = 'SEPA_COLLECTIVE_MONEY_TRANSFER';
    const SUPPORTED_ORDERS_BASIC_DIRECT_DEBIT = 'SEPA_BASIC_DIRECT_DEBIT';
    const SUPPORTED_ORDERS_BASIC_COLLECTIVE_DIRECT_DEBIT = 'SEPA_BASIC_COLLECTIVE_DIRECT_DEBIT';
    const SUPPORTED_ORDERS_B2_B_DIRECT_DEBIT = 'SEPA_B2B_DIRECT_DEBIT';
    const SUPPORTED_ORDERS_B2_B_COLLECTIVE_DIRECT_DEBIT = 'SEPA_B2B_COLLECTIVE_DIRECT_DEBIT';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAccountTypeAllowableValues()
    {
        return [
            self::ACCOUNT_TYPE_CHECKING,
            self::ACCOUNT_TYPE_SAVINGS,
            self::ACCOUNT_TYPE_CREDIT_CARD,
            self::ACCOUNT_TYPE_SECURITY,
            self::ACCOUNT_TYPE_LOAN,
            self::ACCOUNT_TYPE_POCKET,
            self::ACCOUNT_TYPE_MEMBERSHIP,
            self::ACCOUNT_TYPE_BAUSPAREN,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_UPDATED,
            self::STATUS_UPDATED_FIXED,
            self::STATUS_DOWNLOAD_IN_PROGRESS,
            self::STATUS_DOWNLOAD_FAILED,
            self::STATUS_DEPRECATED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSupportedOrdersAllowableValues()
    {
        return [
            self::SUPPORTED_ORDERS_MONEY_TRANSFER,
            self::SUPPORTED_ORDERS_COLLECTIVE_MONEY_TRANSFER,
            self::SUPPORTED_ORDERS_BASIC_DIRECT_DEBIT,
            self::SUPPORTED_ORDERS_BASIC_COLLECTIVE_DIRECT_DEBIT,
            self::SUPPORTED_ORDERS_B2_B_DIRECT_DEBIT,
            self::SUPPORTED_ORDERS_B2_B_COLLECTIVE_DIRECT_DEBIT,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['bank_connection_id'] = isset($data['bank_connection_id']) ? $data['bank_connection_id'] : null;
        $this->container['account_name'] = isset($data['account_name']) ? $data['account_name'] : null;
        $this->container['iban'] = isset($data['iban']) ? $data['iban'] : null;
        $this->container['account_number'] = isset($data['account_number']) ? $data['account_number'] : null;
        $this->container['sub_account_number'] = isset($data['sub_account_number']) ? $data['sub_account_number'] : null;
        $this->container['account_holder_name'] = isset($data['account_holder_name']) ? $data['account_holder_name'] : null;
        $this->container['account_holder_id'] = isset($data['account_holder_id']) ? $data['account_holder_id'] : null;
        $this->container['account_currency'] = isset($data['account_currency']) ? $data['account_currency'] : null;
        $this->container['account_type_id'] = isset($data['account_type_id']) ? $data['account_type_id'] : null;
        $this->container['account_type_name'] = isset($data['account_type_name']) ? $data['account_type_name'] : null;
        $this->container['account_type'] = isset($data['account_type']) ? $data['account_type'] : null;
        $this->container['balance'] = isset($data['balance']) ? $data['balance'] : null;
        $this->container['overdraft'] = isset($data['overdraft']) ? $data['overdraft'] : null;
        $this->container['overdraft_limit'] = isset($data['overdraft_limit']) ? $data['overdraft_limit'] : null;
        $this->container['available_funds'] = isset($data['available_funds']) ? $data['available_funds'] : null;
        $this->container['last_successful_update'] = isset($data['last_successful_update']) ? $data['last_successful_update'] : null;
        $this->container['last_update_attempt'] = isset($data['last_update_attempt']) ? $data['last_update_attempt'] : null;
        $this->container['is_new'] = isset($data['is_new']) ? $data['is_new'] : null;
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
        $this->container['supported_orders'] = isset($data['supported_orders']) ? $data['supported_orders'] : null;
        $this->container['interfaces'] = isset($data['interfaces']) ? $data['interfaces'] : null;
        $this->container['clearing_accounts'] = isset($data['clearing_accounts']) ? $data['clearing_accounts'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['id'] === null) {
            $invalidProperties[] = "'id' can't be null";
        }
        if ($this->container['bank_connection_id'] === null) {
            $invalidProperties[] = "'bank_connection_id' can't be null";
        }
        if ($this->container['account_number'] === null) {
            $invalidProperties[] = "'account_number' can't be null";
        }
        if ($this->container['account_type_id'] === null) {
            $invalidProperties[] = "'account_type_id' can't be null";
        }
        if ($this->container['account_type_name'] === null) {
            $invalidProperties[] = "'account_type_name' can't be null";
        }
        $allowedValues = $this->getAccountTypeAllowableValues();
        if (!is_null($this->container['account_type']) && !in_array($this->container['account_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'account_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['is_new'] === null) {
            $invalidProperties[] = "'is_new' can't be null";
        }
        if ($this->container['status'] === null) {
            $invalidProperties[] = "'status' can't be null";
        }
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'status', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['supported_orders'] === null) {
            $invalidProperties[] = "'supported_orders' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets id
     *
     * @return int
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param int $id Account identifier
     *
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets bank_connection_id
     *
     * @return int
     */
    public function getBankConnectionId()
    {
        return $this->container['bank_connection_id'];
    }

    /**
     * Sets bank_connection_id
     *
     * @param int $bank_connection_id Identifier of the bank connection that this account belongs to
     *
     * @return $this
     */
    public function setBankConnectionId($bank_connection_id)
    {
        $this->container['bank_connection_id'] = $bank_connection_id;

        return $this;
    }

    /**
     * Gets account_name
     *
     * @return string
     */
    public function getAccountName()
    {
        return $this->container['account_name'];
    }

    /**
     * Sets account_name
     *
     * @param string $account_name Account name
     *
     * @return $this
     */
    public function setAccountName($account_name)
    {
        $this->container['account_name'] = $account_name;

        return $this;
    }

    /**
     * Gets iban
     *
     * @return string
     */
    public function getIban()
    {
        return $this->container['iban'];
    }

    /**
     * Sets iban
     *
     * @param string $iban Account's IBAN. Note that this field can change from 'null' to a value - or vice versa - any time when the account is being updated. This is subject to changes within the bank's internal account management.
     *
     * @return $this
     */
    public function setIban($iban)
    {
        $this->container['iban'] = $iban;

        return $this;
    }

    /**
     * Gets account_number
     *
     * @return string
     */
    public function getAccountNumber()
    {
        return $this->container['account_number'];
    }

    /**
     * Sets account_number
     *
     * @param string $account_number (National) account number. Note that this value might change whenever the account is updated (for example, leading zeros might be added or removed).
     *
     * @return $this
     */
    public function setAccountNumber($account_number)
    {
        $this->container['account_number'] = $account_number;

        return $this;
    }

    /**
     * Gets sub_account_number
     *
     * @return string
     */
    public function getSubAccountNumber()
    {
        return $this->container['sub_account_number'];
    }

    /**
     * Sets sub_account_number
     *
     * @param string $sub_account_number Account's sub-account-number. Note that this field can change from 'null' to a value - or vice versa - any time when the account is being updated. This is subject to changes within the bank's internal account management.
     *
     * @return $this
     */
    public function setSubAccountNumber($sub_account_number)
    {
        $this->container['sub_account_number'] = $sub_account_number;

        return $this;
    }

    /**
     * Gets account_holder_name
     *
     * @return string
     */
    public function getAccountHolderName()
    {
        return $this->container['account_holder_name'];
    }

    /**
     * Sets account_holder_name
     *
     * @param string $account_holder_name Name of the account holder
     *
     * @return $this
     */
    public function setAccountHolderName($account_holder_name)
    {
        $this->container['account_holder_name'] = $account_holder_name;

        return $this;
    }

    /**
     * Gets account_holder_id
     *
     * @return string
     */
    public function getAccountHolderId()
    {
        return $this->container['account_holder_id'];
    }

    /**
     * Sets account_holder_id
     *
     * @param string $account_holder_id Bank's internal identification of the account holder. Note that if your client has no license for processing this field, it will always be 'XXXXX'
     *
     * @return $this
     */
    public function setAccountHolderId($account_holder_id)
    {
        $this->container['account_holder_id'] = $account_holder_id;

        return $this;
    }

    /**
     * Gets account_currency
     *
     * @return string
     */
    public function getAccountCurrency()
    {
        return $this->container['account_currency'];
    }

    /**
     * Sets account_currency
     *
     * @param string $account_currency Account's currency
     *
     * @return $this
     */
    public function setAccountCurrency($account_currency)
    {
        $this->container['account_currency'] = $account_currency;

        return $this;
    }

    /**
     * Gets account_type_id
     *
     * @return int
     */
    public function getAccountTypeId()
    {
        return $this->container['account_type_id'];
    }

    /**
     * Sets account_type_id
     *
     * @param int $account_type_id Identifier of the account's type. Note that, in general, the type of an account can change any time when the account is being updated. This is subject to changes within the bank's internal account management. However, if the account's type has previously been changed explicitly (via the PATCH method), then the explicitly set type will NOT be automatically changed anymore, even if the type has changed on the bank side. <br/>Note: this field is deprecated and would be removed at some point. Please refer to new field in 'accountType' instead.<br/>1 = Checking,<br/>2 = Savings,<br/>3 = CreditCard,<br/>4 = Security,<br/>5 = Loan,<br/>6 = Pocket (DEPRECATED; will not be returned for any account unless this type has explicitly been set via PATCH),<br/>7 = Membership,<br/>8 = Bausparen<br/>
     *
     * @return $this
     */
    public function setAccountTypeId($account_type_id)
    {
        $this->container['account_type_id'] = $account_type_id;

        return $this;
    }

    /**
     * Gets account_type_name
     *
     * @return string
     */
    public function getAccountTypeName()
    {
        return $this->container['account_type_name'];
    }

    /**
     * Sets account_type_name
     *
     * @param string $account_type_name Name of the account's type<br/>Note: this field is deprecated and would be removed at some point. Please refer to new field in 'accountType' instead.
     *
     * @return $this
     */
    public function setAccountTypeName($account_type_name)
    {
        $this->container['account_type_name'] = $account_type_name;

        return $this;
    }

    /**
     * Gets account_type
     *
     * @return string
     */
    public function getAccountType()
    {
        return $this->container['account_type'];
    }

    /**
     * Sets account_type
     *
     * @param string $account_type An account type.<br/><br/>Checking,<br/>Savings,<br/>CreditCard,<br/>Security,<br/>Loan,<br/>Pocket (DEPRECATED; will not be returned for any account unless this type has explicitly been set via PATCH),<br/>Membership,<br/>Bausparen<br/><br/>
     *
     * @return $this
     */
    public function setAccountType($account_type)
    {
        $allowedValues = $this->getAccountTypeAllowableValues();
        if (!is_null($account_type) && !in_array($account_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'account_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['account_type'] = $account_type;

        return $this;
    }

    /**
     * Gets balance
     *
     * @return float
     */
    public function getBalance()
    {
        return $this->container['balance'];
    }

    /**
     * Sets balance
     *
     * @param float $balance Current account balance
     *
     * @return $this
     */
    public function setBalance($balance)
    {
        $this->container['balance'] = $balance;

        return $this;
    }

    /**
     * Gets overdraft
     *
     * @return float
     */
    public function getOverdraft()
    {
        return $this->container['overdraft'];
    }

    /**
     * Sets overdraft
     *
     * @param float $overdraft Current overdraft
     *
     * @return $this
     */
    public function setOverdraft($overdraft)
    {
        $this->container['overdraft'] = $overdraft;

        return $this;
    }

    /**
     * Gets overdraft_limit
     *
     * @return float
     */
    public function getOverdraftLimit()
    {
        return $this->container['overdraft_limit'];
    }

    /**
     * Sets overdraft_limit
     *
     * @param float $overdraft_limit Overdraft limit
     *
     * @return $this
     */
    public function setOverdraftLimit($overdraft_limit)
    {
        $this->container['overdraft_limit'] = $overdraft_limit;

        return $this;
    }

    /**
     * Gets available_funds
     *
     * @return float
     */
    public function getAvailableFunds()
    {
        return $this->container['available_funds'];
    }

    /**
     * Sets available_funds
     *
     * @param float $available_funds Current available funds. Note that this field is only set if finAPI can make a definite statement about the current available funds. This might not always be the case, for example if there is not enough information available about the overdraft limit and current overdraft.
     *
     * @return $this
     */
    public function setAvailableFunds($available_funds)
    {
        $this->container['available_funds'] = $available_funds;

        return $this;
    }

    /**
     * Gets last_successful_update
     *
     * @return string
     */
    public function getLastSuccessfulUpdate()
    {
        return $this->container['last_successful_update'];
    }

    /**
     * Sets last_successful_update
     *
     * @param string $last_successful_update THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the corresponding field in 'interfaces' instead.<br/><br/>Timestamp of when the account was last successfully updated (or initially imported); more precisely: time when the account data (balance and positions) has been stored into the finAPI databases. The value is returned in the format 'YYYY-MM-DD HH:MM:SS.SSS' (german time).
     *
     * @return $this
     */
    public function setLastSuccessfulUpdate($last_successful_update)
    {
        $this->container['last_successful_update'] = $last_successful_update;

        return $this;
    }

    /**
     * Gets last_update_attempt
     *
     * @return string
     */
    public function getLastUpdateAttempt()
    {
        return $this->container['last_update_attempt'];
    }

    /**
     * Sets last_update_attempt
     *
     * @param string $last_update_attempt THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the corresponding field in 'interfaces' instead.<br/><br/>Timestamp of when the account was last tried to be updated (or initially imported); more precisely: time when the update (or initial import) was triggered. The value is returned in the format 'YYYY-MM-DD HH:MM:SS.SSS' (german time).
     *
     * @return $this
     */
    public function setLastUpdateAttempt($last_update_attempt)
    {
        $this->container['last_update_attempt'] = $last_update_attempt;

        return $this;
    }

    /**
     * Gets is_new
     *
     * @return bool
     */
    public function getIsNew()
    {
        return $this->container['is_new'];
    }

    /**
     * Sets is_new
     *
     * @param bool $is_new Indicating whether this account is 'new' or not. Any newly imported account will have this flag initially set to true, and remain so until you set it to false (see PATCH /accounts/<id>). How you use this field is up to your interpretation, however it is recommended to set the flag to false for all accounts right after the initial import of the bank connection. This way, you will be able recognize accounts that get newly imported during a later update of the bank connection, by checking for any accounts with the flag set to true right after an update.
     *
     * @return $this
     */
    public function setIsNew($is_new)
    {
        $this->container['is_new'] = $is_new;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string $status THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the 'status' field in 'interfaces' instead.<br/><br/>The current status of the account. Possible values are:<br/>&bull; <code>UPDATED</code> means that the account is up to date from finAPI's point of view. This means that no current import/update is running, and the previous import/update could successfully update the account's data (e.g. transactions and securities), and the bank given balance matched the transaction's calculated sum, meaning that no adjusting entry ('Zwischensaldo' transaction) was inserted.<br/>&bull; <code>UPDATED_FIXED</code> means that the account is up to date from finAPI's point of view (no current import/update is running, and the previous import/update could successfully update the account's data), BUT there was a deviation in the bank given balance which was fixed by adding an adjusting entry ('Zwischensaldo' transaction).<br/>&bull; <code>DOWNLOAD_IN_PROGRESS</code> means that the account's data is currently being imported/updated.<br/>&bull; <code>DOWNLOAD_FAILED</code> means that the account data could not get successfully imported or updated. Possible reasons: finAPI could not get the account's balance, or it could not parse all transactions/securities, or some internal error has occurred. Also, it could mean that finAPI could not even get to the point of receiving the account data from the bank server, for example because of incorrect login credentials or a network problem. Note however that when we get a balance and just an empty list of transactions or securities, then this is regarded as valid and successful download. The reason for this is that for some accounts that have little activity, we may actually get no recent transactions but only a balance.<br/>&bull; <code>DEPRECATED</code> means that the account could no longer get matched with any account from the bank server. This can mean either that the account was terminated by the user and is no longer sent by the bank server, or that finAPI could no longer match it because the account's data (name, type, iban, account number, etc.) has been changed by the bank.
     *
     * @return $this
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'status', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets supported_orders
     *
     * @return string[]
     */
    public function getSupportedOrders()
    {
        return $this->container['supported_orders'];
    }

    /**
     * Sets supported_orders
     *
     * @param string[] $supported_orders THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the 'capabilities' in 'interfaces' field instead.<br/><br/>List of orders that this account supports. Possible values are:<br/><br/>&bull; <code>SEPA_MONEY_TRANSFER</code> - single money transfer<br/>&bull; <code>SEPA_COLLECTIVE_MONEY_TRANSFER</code> - collective money transfer<br/>&bull; <code>SEPA_BASIC_DIRECT_DEBIT</code> - single basic direct debit<br/>&bull; <code>SEPA_BASIC_COLLECTIVE_DIRECT_DEBIT</code> - collective basic direct debit<br/>&bull; <code>SEPA_B2B_DIRECT_DEBIT</code> - single Business-To-Business direct debit<br/>&bull; <code>SEPA_B2B_COLLECTIVE_DIRECT_DEBIT</code> - collective Business-To-Business direct debit<br/><br/>Note that this list may be empty if the account is not supporting any of the above orders. Also note that the list is refreshed each time the account is being updated, so available orders may get added or removed in the course of an account update.
     *
     * @return $this
     */
    public function setSupportedOrders($supported_orders)
    {
        $allowedValues = $this->getSupportedOrdersAllowableValues();
        if (array_diff($supported_orders, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'supported_orders', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['supported_orders'] = $supported_orders;

        return $this;
    }

    /**
     * Gets interfaces
     *
     * @return \Swagger\Client\Model\AccountInterface[]
     */
    public function getInterfaces()
    {
        return $this->container['interfaces'];
    }

    /**
     * Sets interfaces
     *
     * @param \Swagger\Client\Model\AccountInterface[] $interfaces Set of interfaces to which this account is connected
     *
     * @return $this
     */
    public function setInterfaces($interfaces)
    {
        $this->container['interfaces'] = $interfaces;

        return $this;
    }

    /**
     * Gets clearing_accounts
     *
     * @return \Swagger\Client\Model\ClearingAccountData[]
     */
    public function getClearingAccounts()
    {
        return $this->container['clearing_accounts'];
    }

    /**
     * Sets clearing_accounts
     *
     * @param \Swagger\Client\Model\ClearingAccountData[] $clearing_accounts List of clearing accounts that relate to this account. Clearing accounts can be used for money transfers (see field 'clearingAccountId' of the 'Request SEPA Money Transfer' service).<br><br>NOTE: This field is deprecated and will be removed at some point.
     *
     * @return $this
     */
    public function setClearingAccounts($clearing_accounts)
    {
        $this->container['clearing_accounts'] = $clearing_accounts;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


